<?php/*PHPSUDO 2.0 LicenceCopyright © Nicolas Lion, 17/04/2008Email : nicolas@lioninformatique.comSite : http://www.lioninformatique.com*******************************************************************************************************************************                                                                                                                         ****   Ce logiciel est un programme informatique pour jouer au sudoku. Il génère des grilles à solution unique.              ****   Ce logiciel est régi par la licence CeCILL-B soumise au droit français et respectant les principes                    ****   de diffusion des logiciels libres. Vous pouvez utiliser, modifier et/ou redistribuer ce programme                     ****   sous les conditions de la licence CeCILL-B telle que diffusée par le CEA, le CNRS et l'INRIA sur                      ****   le site "http://www.cecill.info".                                                                                     ****                                                                                                                         ****   En contrepartie de l'accessibilité au code source et des droits de copie, de modification et de                       ****   redistribution accordés par cette licence, il n'est offert aux utilisateurs qu'une garantie limitée.                  ****   Pour les mêmes raisons, seule une responsabilité restreinte pèse sur l'auteur du programme, le titulaire              ****   des droits patrimoniaux et les concédants successifs.                                                                 ****                                                                                                                         ****   A cet égard l'attention de l'utilisateur est attirée sur les risques associés au chargement, à                        ****   l'utilisation, à la modification et/ou au développement et à la reproduction du logiciel par                          ** **   l'utilisateur étant donné sa spécificité de logiciel libre, qui peut le rendre complexe à manipuler et qui            ****   le réserve donc à des développeurs et des professionnels avertis possédant des connaissances informatiques            ****   approfondies. Les utilisateurs sont donc invités à charger et tester l'adéquation du logiciel à leurs besoins         ****   dans des conditions permettant d'assurer la sécurité de leurs systèmes et ou de leurs données et,                     ****   plus généralement, à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.                                 ****                                                                                                                         ****   Le fait que vous puissiez accéder à cet en-tête signifie que vous avez pris connaissance de la licence CeCILL-B,      ****   et que vous en avez accepté les termes.                                                                               ****                                                                                                                         ******************************************************************************************************************************* */Class calculGrillePleine{  var $SudoVide = array(array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0));  var $tirage;  var $sudo;  var $max;  var $min;  var $NbCasesHZone; //nombre de cases horyzontale dans une zone   var $NbCasesVZone; //nombre de cases verticale dans une zone   var $TimeLimitCalcul=6; //temps limite de calcule d'une grille en seconde  var $TimeOut=false; //temps d'execution trop long Timeout  var $fin=false;    function zone($tab,$ligne, $colonne)   {   while($ligne % $this->NbCasesHZone) $ligne--;   while($colonne % $this->NbCasesVZone) $colonne--;   for($j=$ligne; $j<$ligne+$this->NbCasesHZone; $j++)    {      for($i=$colonne; $i<$colonne+$this->NbCasesVZone; $i++)      {         $res[]=$tab[$j][$i];      }   }   return $res;  }    function colonne($colonne)   {    for($i=0; $i<$this->max; $i++)       $res[]=$this->sudo[$i][$colonne];   return $res;  }    function Grille($i=0)   {    for($ligne=$i; $ligne<$this->max; $ligne++)     {      for($colonne=0; $colonne<$this->max; $colonne++)       {         // un chiffre dans la case ?         if($this->sudo[$ligne][$colonne]) continue;                 shuffle($this->tirage);          for($k=0; $k<sizeof($this->tirage); $k++)          {             $nbre = $this->tirage[$k];            // chiffre dans la ligne ?            if(in_array($nbre,$this->sudo[$ligne])) continue;            // chiffre dans la colonne ?            if(in_array($nbre,$this->colonne($colonne))) continue;            //  chiffre est dans la zone ?            if(in_array($nbre,$this->zone($this->sudo,$ligne,$colonne))) continue;                       $nbre_res=$this->sudo[$ligne][$colonne];             $this->sudo[$ligne][$colonne]=$nbre;            // grille terminée ?            if(($ligne==$this->max-1)&&($colonne==$this->max-1)) $this->fin=true;            if($this->fin) return;            // sinon on continu            $this->Grille($ligne);            // chiffre suivant            if(!$this->fin && (time()-$this->t0)<$this->TimeLimitCalcul){$this->sudo[$ligne][$colonne]=$nbre_res;}            else if (!$this->fin && (time()-$this->t0>=$this->TimeLimitCalcul)){break;$this->TimeOut=true;} //temps execution trop long          }         return;      }   }  }}class SuDoKu extends calculGrillePleine{    var $level=0; //niveau de difficulté -> null = deduction en croix + zone par valeur interdite    var $LevelHard=0;    var $CountSearch=0;    var $TabValeursPossible;    var $YTabValeursPossible;    var $XTabValeursPossible;    var $LimitNiveau;    var $GrillePleine; // une grille pleine    var $IncompleteGrille; //    var $TestGrilleSudoku; //grille de test pour verifier la validité d'une grille de sudoku    var $ValidIncompleteGrille=false; //statut de la grille unique solution ou pas    var $CasesVidesCoordonneesX=null;    var $CasesVidesCoordonneesY=null;    var $WithSymbol=false;    var $t0;    function Sudoku($init=true,$max=4,$min=2,$level=0) //6*2 ou 4*2 ou 9*3 ...    {        $this->max=$max; //pour modifier taille sudoku !         $this->min=$min;        $this->level=$level;        $this->NbCasesVZone=$this->max/$this->min; //resultat doit être un entier //3-2-3        $this->NbCasesHZone=$this->min;                 if($init) $this->init();    }        function init()    {        $this->t0=time();        $this->GetGrille();                  $i=0;        while (!$this->ValidIncompleteGrille && (time()-$this->t0)<$this->TimeLimitCalcul) //tant qu'il n'y a pas une grille qui a été trouvé et que le temps de recherche <= 10secondes        {                              if (isset($this->CasesVidesCoordonneesX)) unset($this->CasesVidesCoordonneesX,$this->CasesVidesCoordonneesY);          $this->create_grille_sudoku();                   }                if (!$this->ValidIncompleteGrille) //si la grille n'a pas été trouvé on recharge la page => pour eviter timeout        {                        $this->TimeOut=true;             }    }        function GetGrille()    {        $this->tirage = range(1,$this->max);        $this->sudo=$this->SudoVide; $this->Grille();        $this->GrillePleine=$this->sudo;    }    function NiveauDifficulte()    {      //$level=0 par defaut            switch ($this->level)      {            case 0:            //facile            if ($this->LevelHard==0)              $statut=true;            break;                        case 1 :              if($this->LevelHard>=1 && $this->LevelHard<=5 && $this->max>4)              {                $statut=true;              }              else if(($this->LevelHard==0 && $this->max==4) ||($this->LevelHard==0 && $this->max==16))              {                $statut=true;              }            break;                        case 2 :              if($this->LevelHard>=155 && $this->max>4)              {                $statut=true;              }              else if(($this->LevelHard==0 && $this->max==4)||($this->LevelHard==0 && $this->max==16)) //moyen = difficile pour la grille 16*16 sinon temps de calcul trop grand              {                $statut=true;              }            break;                        default :            exit ('Le niveau renseigné n\'existe pas');            break;            }      return $statut;    }        function create_grille_sudoku()    {      // future raisonement : à chaque suppression de valeur, il faut verifier que celle-ci peut être retrouvée      // Gain en rapidité ? non traitement plus long car solveur lancé à chaque suppression de valeur      // A tester... 	      //-------------------------------------------------------------------------------------------------------    	      $new_grille=$this->GrillePleine;    	switch ($this->max)    	{    	 case 16 :    	 if($this->level>=1)    	   $NbrInconnus=115;    	 else    	     $NbrInconnus=65;            break;    	  case 14 :    	      $NbrInconnus=90;            break;        case 12 :            $NbrInconnus=73;            break;    	   case 10 :            $NbrInconnus=56;            break;                      case 9 :          if($this->level>1)          $NbrInconnus=47;          else            $NbrInconnus=44;            break;                      case 8:            $NbrInconnus=38;            break;            case 6:            $NbrInconnus=22;            break;          case 4:          if($this->level==1)          $NbrInconnus=10;          else if($this->level==2)          $NbrInconnus=11;          else          $NbrInconnus=6;            break;      }                for ($i=0;$i<=$NbrInconnus;$i++)        	{        	     $X = rand(0,$this->max-1);                $Y = rand(0,$this->max-1);                               //on verfit que ces coordonnées ne sont pas déjà utilisés                 while($new_grille[$X][$Y]==0)                {                   $X = rand(0,$this->max-1);                   $Y = rand(0,$this->max-1);                 }        	     $new_grille[$X][$Y]=0;        	     $this->CasesVidesCoordonneesX[]=$X;               $this->CasesVidesCoordonneesY[]=$Y;	          }                //il faut tester si la grille à une seule solution !        $this->IncompleteGrille=$new_grille;        $this->TestGrilleSudoku=$this->IncompleteGrille;                $grillevalide=$this->CalculSolutionDeduction();                $this->ValidIncompleteGrille=$grillevalide;                if ($this->ValidIncompleteGrille)        {          $this->ValidIncompleteGrille=$this->NiveauDifficulte();        }        $this->CountSearch=0;       //par moment la grille n'est pas vailde, il y a une erreur algo de resolution non résolu encore.       //On teste donc si la grille résolu avec algo de resolution ne contient pas d'erreur      /* TEMPORAIRE */      $res=$this->Debug($this->TestGrilleSudoku);       if($res>=1 && $this->ValidIncompleteGrille)          $this->ValidIncompleteGrille=false;                 //echo    $res.'<br/>';       /* FIN */                 return $grillevalide;    }    function replace_by_symbol($Val,$transform=false)    {        // On remplace les numéro par des symbole (lettres)                $tab=array(1=>'A',2=>'B',3=>'C',4=>'D',5=>'E',6=>'F',7=>'G',8=>'H',9=>'I',10=>'J',11=>'K',12=>'L',13=>'M',14=>'N',15=>'O',16=>'P');                if ($transform)        {          if (is_int($Val))            return $tab[$Val];          else          {             array_flip($tab); //Remplace les clés par les valeurs, et les valeurs par les clés             return $tab[$Val];          }        }        else          return $Val;       }    // On dessine le sudoku    function drawing($grille=null,$template='Grille.tpl')    {        //Utilisation du template !        Global $path;        $tpl = new template($path.'Templates/');         for($y=0;$y<$this->max;$y++)        {                    //on cadrille la grille          if ($y%$this->NbCasesVZone==0)					{                $classCSS.='TopCase BorderRightNull BorderBottomNull'; 							 if (($y<=1) || ($y<=($this->NbCasesVZone+1) && $y>=$this->NbCasesVZone) || ($y<=($this->max-$this->NbCasesVZone+1) && $y>=($this->max-$this->NbCasesVZone)) || (($this->max%$this->NbCasesVZone==0))) $classCSS.=' BorderLeft';           }          else 					{							$classCSS='BorderLeft BorderTop BorderRightNull BorderBottomNull'; 							if ($y==$this->max-1){ $classCSS.=' BottomCase';$classCSS=str_replace('BorderBottom','',$classCSS);} 					}          for ($x=0;$x<$this->max;$x++)					{					  					  if ($x%$this->NbCasesHZone==0) 						{						    $classCSSFinal=str_replace('BorderLeft','LeftCase',$classCSS);												}						else 						{								if ($x==($this->max-1)){$classCSS.=' RightCase';$classCSS=str_replace('BorderRightNull','',$classCSS);}									 $classCSSFinal.=$classCSS;						}										  if ($x==0)					  {              $array['DIV']='<div style="margin-top:-2px;padding-top:0px;">';              $array['/DIV']='';            }            else            {               $array['DIV']='';					  }					  					  if ($x==($this->max-1)) $array['/DIV']='</div>';					   					    $array['class']=$classCSSFinal;              $array['coord']=$x.$y;                            if ($grille[$x][$y]!=0)              {                $array['Disabled']=' disabled="disabled"';                 $array['class']=$array['class'].' Disabled';                 $array['value']=$this->replace_by_symbol($grille[$x][$y],$this->WithSymbol);              }              else              {                $array['Disabled']='';                $array['value']='';                if (isset($_POST['case_'.$x.$y]))                  $array['value']=$_POST['case_'.$x.$y]; //a revoir              }                            $tpl->bloc('Cases',$array,$template);                              $array['DIV']='';                            $classCSSFinal='';          }          $classCSS='';       }        //on affiche la grille        return $tpl;     } function Correction($Values) //values=contient variables posts {    //correction       /*        On verifit que toutes les cases ont été remplies        + Mise en forme du formulaire pour avoir la même structure que la variable sessions $_SESSION['GrilleSolution']        + On compare les grilles à la solution      */      $nbr_erreurs=0;      for ($y=0;$y<$this->max;$y++)      {          for ($x=0;$x<$this->max;$x++)          {              if (isset($Values['case_'.$x.$y])) //les cases remplies sont disabled donc variable post n'existe pas              {                  //On verifit que la case est remplie                  if($Values['case_'.$x.$y]!='')                  {                      //on compare à la solution                      if (!is_int(htmlentities($Values['case_'.$x.$y]))) $Values['case_'.$x.$y]=strtoupper(htmlentities($Values['case_'.$x.$y])); //si symbole et que l'utilisateur ecris en minuscule                      if(htmlentities($Values['case_'.$x.$y])!=$this->replace_by_symbol($this->GrillePleine[$x][$y],$this->WithSymbol))                      {                          $nbr_erreurs++;                      }                  }                  else                  {                      $nbr_erreurs++;                  }              }          }      }      return $nbr_erreurs; }function UnsetInconnus($x,$y){    //les coordoonnées des inconnus :    //$this->CasesVidesCoordonneesX[$i];     for ($i=0;$i<count($this->CasesVidesCoordonneesX);$i++)     {        if($this->CasesVidesCoordonneesX[$i]==$x && $this->CasesVidesCoordonneesY[$i]==$y)        {          //unset($this->CasesVidesCoordonneesX[$i],$this->CasesVidesCoordonneesY[$i]);        }         else        {          $NewArraX[]=$this->CasesVidesCoordonneesX[$i];          $NewArraY[]=$this->CasesVidesCoordonneesY[$i];          //$NewTabValeursPossible[]=$this->TabValeursPossible[$i];        }       }              $this->CasesVidesCoordonneesX=$NewArraX;     $this->CasesVidesCoordonneesY=$NewArraY;     //$this->TabValeursPossible =$NewTabValeursPossible;            }function ValeursInterdites($x,$y) {         $val[]=0;      //methode en croix !            //ligne      for ($j=0;$j<$this->max;$j++)      {          if ($this->TestGrilleSudoku[$x][$j]!=0)          {            if(!in_array($this->TestGrilleSudoku[$x][$j],$val))              $val[]=$this->TestGrilleSudoku[$x][$j];                }      }      //colonne      for ($i=0;$i<$this->max;$i++)      {        if ($this->TestGrilleSudoku[$i][$y]!=0)        {              //on verfit que la valeur interdite n'est pas déjà stoqué              if(!in_array($this->TestGrilleSudoku[$i][$y],$val))                $val[]=$this->TestGrilleSudoku[$i][$y];                   }      }      while($x % $this->NbCasesHZone) $x--;      while($y % $this->NbCasesVZone) $y--;      for($i=$x; $i<$x+$this->NbCasesHZone; $i++)       {        for($j=$y; $j<$y+$this->NbCasesVZone; $j++)        {          if(!in_array($this->TestGrilleSudoku[$i][$j],$val))                $val[]=$this->TestGrilleSudoku[$i][$j];        }      }        //$val contient toutes les valeurs interdites        return $val; }    function DeductionParValeurInterdites($x,$y,$valsinterdits) {    //$ValeurPossible=array(1,2,3,4,5,6,7,8,9 ...)    //valeurs possible    for ($i=1;$i<=$this->max;$i++)    {        //on cherche si les valeur possibles est dans les valeurs interdites        if(!in_array($i,$valsinterdits))        {            //cette valeur n'est pas interdite              $val[]=$i;          }    }  return $val; } function DeductionSolitaireNu($X,$Y)  //"solitaire nu" unique visible ou caché {      $find=false;             for($u=0;$u<$this->max;$u++)      {          $keys=array_keys($Y, $u);          //if ($count($keys)==0) $TabValeursPossibles          for($w=0;$w<count($keys);$w++)          {              $TabValeursPossibles[]=$this->TabValeursPossible[$keys[$w]];              $y[]=$Y[$keys[$w]];              $x[]=$X[$keys[$w]];          }                       //balayage de tous les tableaux de chaque case inconnu de la ligne ou de la colonne                for ($n=0;$n<count($TabValeursPossibles);$n++)        {               $count=0;                         $ValsATester=$TabValeursPossibles[$n];             $x_=$x[$n];            $y_=$y[$n];                         for ($i=0;$i<count($ValsATester);$i++)            {                $valatest=$ValsATester[$i];                                for($j=0;$j<count($TabValeursPossibles);$j++)                {                  $TabValeursPossiblesAComparer=$TabValeursPossibles[$j];                  if(count($TabValeursPossiblesAComparer)>0)                  if(in_array($valatest,$TabValeursPossiblesAComparer) && $j!=$n)                  {                    $count++;                   }                }                if($count==0)                  {                       if ($this->TestGrilleSudoku[$x_][$y_]==0)                    {                        $this->TestGrilleSudoku[$x_][$y_]=$valatest;                        // on a une valeure unique debug                        //echo 'X='.$x_.' : Y='.$y_.'-->'.$valatest."<br />";                        $find=true;                        $this->UnsetInconnus($x_,$y_);                        break(3);                     }                          }              }                     }            unset($TabValeursPossibles,$y,$x);       }                        return $find;                       }  function SearchPairesNues($TabValeursPossibles,$y,$x) {    $find=FALSE;    for ($n=0;$n<count($TabValeursPossibles);$n++)    {             $ValsATester=$TabValeursPossibles[$n];         $x_=$x[$n];        $y_=$y[$n];                 if(count($ValsATester)==3)           for ($i=0;$i<count($ValsATester);$i++)        {                //groupes de paires à chercher : [0][1];[0][2];[1][2];                  switch ($i)                {                    case 0 :                      $valatest[0]=$ValsATester[0];                      $res=$ValsATester[2];                      $valatest[1]=$ValsATester[1];                    break;                                                  case 1 :                      $valatest[0]=$ValsATester[0];                      $res=$ValsATester[1];                      $valatest[1]=$ValsATester[2];                    break;                                                  case 2:                      $valatest[0]=$ValsATester[1];                      $res=$ValsATester[0];                      $valatest[1]=$ValsATester[2];                    break;                }                $count=0;                for($j=0;$j<count($TabValeursPossibles);$j++)                {                     $TabValeursPossiblesAComparer=$TabValeursPossibles[$j];                    //il faut trouver les paires identiques dans la ligne                    if(count($TabValeursPossiblesAComparer)==2 && in_array($valatest[0],$TabValeursPossiblesAComparer) && in_array($valatest[1],$TabValeursPossiblesAComparer) && $j!=$n)                    {                       $count++;                      }                   }                                    if($count==2)                {                          if ($this->TestGrilleSudoku[$x_][$y_]==0)                       {                          $this->TestGrilleSudoku[$x_][$y_]=$res;                                                    // on a une valeure unique debug                          //echo 'X='.$x_.' : Y='.$y_.'-->'.$res."<br />";                          $this->LevelHard=$this->LevelHard+5;                          $find=true;                                                                      $this->UnsetInconnus($x_,$y_);                          break(2);                        }                        }                                                         }      }   return $find; } function SearchPairesNuesCache($TabValeursPossibles,$x,$y) {    $find=FALSE;    for ($n=0;$n<count($TabValeursPossibles);$n++)    {             $ValsATester=$TabValeursPossibles[$n];        $nbrValeurs=count($ValsATester);                       //groupes de paires à chercher : [0][1];[0][2];[0][3];[0][4];[0][5];[0][6];[0][7];[1][2];[1][3];...;[2][3]            if($nbrValeurs>2)            for($i=0;$i<$nbrValeurs-1;$i++)            {                                 $c=$i+1;                 //création des groupes de paires                for($j=$c;$j<$nbrValeurs;$j++)                {                    $paire[0]=$ValsATester[$i];                    $paire[1]=$ValsATester[$j];                                        //on cherche cette paire dans toutes les cases                    $count=0;                                        for($z=0;$z<count($TabValeursPossibles);$z++)                    {                                             $TabValeursPossiblesAComparer=$TabValeursPossibles[$z];                      //il faut trouver les paires identiques dans la ligne                      if(count($paire)==2 && count($TabValeursPossiblesAComparer)>=2)                      if (in_array($paire[0],$TabValeursPossiblesAComparer) && in_array($paire[1],$TabValeursPossiblesAComparer))                      {                        $positionx[]=$x[$z];                        $positiony[]=$y[$z];                        $count++;                      }                        if($count>2) break;                     }                    if($count==2)                    {                                                $Countmaj=0;                        //il faut chercher index                         for($w=0;$w<count($this->TabValeursPossible);$w++)                        {                          if(($this->YTabValeursPossible[$w]==$positiony[0] && $this->XTabValeursPossible[$w]==$positionx[0]) || ($this->YTabValeursPossible[$w]==$positiony[1] && $this->XTabValeursPossible[$w]==$positionx[1]))                          {                              $this->TabValeursPossible[$w]=$paire;                              $Countmaj++;                          }                          if($Countmaj==2){ $find=true;$this->LevelHard=$this->LevelHard+150;break;}                         }                                                break(3);                    }                    else                    {                      unset($positiony,$positionx,$paire);                    }                    }                  //on enregistre la paire cherché pour ne pas lancer une nouvelle recherche avec les même valeurs            }  }   return $find; }     function SelectValues($X,$Y,$type='x',$Methode='PairesNues') {      $find=false;                   if($type=='x' || $type=='y')      {                for($u=0;$u<$this->max;$u++)                {                    switch($type)                    {                        case 'x' : //colonne                        $keys=array_keys($Y, $u);                        break;                                                case 'y' : //ligne                        $keys=array_keys($X, $u);                        break;                      }                    for($w=0;$w<count($keys);$w++)                    {                        $TabValeursPossibles[]=$this->TabValeursPossible[$keys[$w]];                        $y[]=$Y[$keys[$w]];                        $x[]=$X[$keys[$w]];                                            }                                                                     switch ($Methode)                  {                       case 'PairesNues':                        $find=$this->SearchPairesNues($TabValeursPossibles,$y,$x);                        if($find) break(2);                        break;                       case 'PairesNuesCache':                      $find=$this->SearchPairesNuesCache($TabValeursPossibles,$x,$y);                        if($find) break(2);                       break;                                              }                  unset($TabValeursPossibles,$y,$x);                         }       }      else if($type=='xy')      {               //on determine les zones                //nombre de cases par zone => $this->NbCasesVZone; $this->NbCasesHZone                //nombre de zones à balayer -> $this->max^2 / ($this->NbCasesVZone*$this->NbCasesHZone)                $NbrZones=(($this->max*$this->max) / ($this->NbCasesVZone*$this->NbCasesHZone));                for ($u=0;$u<$NbrZones;$u++)                {                    //nbr zone par ligne et par colonne                    $NbrZonesH=$NbrZones/$this->NbCasesHZone;                    $NbrZonesV=$NbrZones/$this->NbCasesVZone;                                        //On determine la zone à étudier                    $InitCaseX=(($u%$NbrZonesH)*$this->NbCasesHZone);                    $InitCaseY=(($u%$NbrZonesV)*$this->NbCasesVZone);                    $EndCaseX=((($u%$NbrZonesH)+1)*$this->NbCasesHZone)-1;                    $EndCaseY=((($u%$NbrZonesV)+1)*$this->NbCasesVZone)-1;                                        for($w=$InitCaseY;$w<=$EndCaseY;$w++)                    {                      $keys=array_keys($Y, $w);                                           if(count($keys)>0)                      for ($z=$InitCaseX;$z<=$EndCaseX;$z++)                      {                          if($X[$keys[$z]]>=$InitCaseX && $X[$keys[$z]]<=$EndCaseX)                          {                                                          $TabValeursPossibles[]=$this->TabValeursPossible[$keys[$z]];                            $y[]=$Y[$keys[$z]];                            $x[]=$X[$keys[$z]];                           }                      }                    }                     //balayage de tous les tableaux de chaque case inconnu de la ligne ou de la colonne                                        switch ($Methode)                    {                       case 'PairesNues':                        $find=$this->SearchPairesNues($TabValeursPossibles,$y,$x);                        if($find) break(2);                        break;                        case 'PairesNuesCache':                      $find=$this->SearchPairesNuesCache($TabValeursPossibles,$x,$y);                        if($find) break(2);                       break;                        }                    unset($TabValeursPossibles,$y,$x);                     }      }                        return $find;   }  function CalculSolutionDeduction() {    /* Solveur de grille par déduction */        $NbrInconnus=count($this->CasesVidesCoordonneesX);        $search=true;        $ALLFind=false;            if ($NbrInconnus==0)        {          $ALLFind=true;        }        else        {            $this->LevelHard=0;                        while ($search)            {                       for($i=0;$i<$NbrInconnus;$i++)                    {                      //liste des valeurs interdites                      if($this->TestGrilleSudoku[$this->CasesVidesCoordonneesX[$i]][$this->CasesVidesCoordonneesY[$i]]!=0)                      {                        //la case est déjà remplie                        $find[]=2;                      }                      else                      {                        $this->CountSearch++;                        $res=$this->ValeursInterdites($this->CasesVidesCoordonneesX[$i],$this->CasesVidesCoordonneesY[$i]);                          $ResDeductionParValeurInterdites=$this->DeductionParValeurInterdites($this->CasesVidesCoordonneesX[$i],$this->CasesVidesCoordonneesY[$i],$res);                                                    if (count($ResDeductionParValeurInterdites)==1)                          {                                                        $this->TestGrilleSudoku[$this->CasesVidesCoordonneesX[$i]][$this->CasesVidesCoordonneesY[$i]]=$ResDeductionParValeurInterdites[0];                                                        $find[]=1;                                                         //on peut supprimer coordonnées de cette inconnue                            $this->UnsetInconnus($this->CasesVidesCoordonneesX[$i],$this->CasesVidesCoordonneesY[$i]);                            $NbrInconnus--;                            $i--;                          }                          else                          {                            $find[]=0;                                                        $this->TabValeursPossible[]=$ResDeductionParValeurInterdites; //contient l'ensemble des valeurs possibles pour chaque cellule                            ////liste des coordonées                            $X[]=$this->CasesVidesCoordonneesX[$i];                            $Y[]=$this->CasesVidesCoordonneesY[$i];                             $this->XTabValeursPossible[]=$this->CasesVidesCoordonneesX[$i];                            $this->YTabValeursPossible[]=$this->CasesVidesCoordonneesY[$i];                          }                        }                      }                    if (!@in_array(0,$find) || $NbrInconnus==0)                    {                      $ALLFind=true; // toutes les valeurs ont été trouvé sur cette boucle                      $search=false;                    }                    else                    {                      if (in_array(1,$find)) // au moin une valeur a été trouvée, on continue la recherche                      {                        $search=true;                      }                      else //aucune valeur n'a été trouvé sur la boucle                      {                        $search=false;                         $ALLFind=false;                        // difficulté supperieur                        // Recherche par deduction toujours mais methode supplémentaire                        $this->LevelHard++;                           //Algo de resolution -->raisonement humain cas par cas                           $search=$this->DeductionSolitaireNu($X,$Y);                                                                              //$this->TabValeursPossible contient toutes les valeurs possibles de chaque cellules                          if(!$search && $this->level>=2)                          {                              //maj $this->TabValeursPossible                              $Newsearch=$this->SelectValues($X,$Y,'y','PairesNuesCache');                              if (!$Newsearch) $Newsearch=$this->SelectValues($X,$Y,'x','PairesNuesCache');                              if (!$Newsearch) $Newsearch=$this->SelectValues($X,$Y,'xy','PairesNuesCache');                                                         }                          if(!$search && $this->level>=1) $search=$this->SelectValues($X,$Y,'x','PairesNues'); //vertical                          if(!$search && $this->level>=1) $search=$this->SelectValues($X,$Y,'y','PairesNues'); //horizontale                          if(!$search && $this->level>=1) $search=$this->SelectValues($X,$Y,'xy','PairesNues') ; //zone                                                                               }                    } //si false aucune valeur deduite dans la boucle on peut arrêter, la grille ne peut pas être resolu par deduction                    //est ce que toutes les valeurs ont été trouvées ?                  unset ($find,$this->TabValeursPossible,$X,$Y,$KeyResolu,$this->YTabValeursPossible,$this->XTabValeursPossible);                 $NbrInconnus=count($this->CasesVidesCoordonneesX);            }          }        return $ALLFind;  }  function Debug($Values) //values=contient variables posts {    //correction       $nbr_erreurs=0;      for ($y=0;$y<$this->max;$y++)      {          for ($x=0;$x<$this->max;$x++)          {                                //On verifit que la case est remplie                                                         //on compare à la solution                      if($Values[$x][$y]!=$this->GrillePleine[$x][$y])                      {                          $nbr_erreurs++;                      }                                        }      }      return $nbr_erreurs; }}?>